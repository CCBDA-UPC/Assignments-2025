#### **Understanding `kwargs` in Python:**

In Python, **`kwargs`** (short for **keyword arguments**) allows you to pass a variable number of named arguments to a function, which are then collected into a dictionary.

##### **Example:**
```python
def greet_user(**kwargs):
    print(kwargs)

greet_user(name="Alice", age=30)

params = {'name': 'Alice', 'age': 30}
greet_user(**params)
```
In both cases the output is
```python
{'name': 'Alice', 'age': 30}
```






## AWS Lambda

**AWS Lambda** is a fully managed **serverless computing service** provided by Amazon Web Services (AWS). It allows developers to run code in response to events without provisioning or managing servers. In simple terms, AWS Lambda lets you focus purely on your code, while AWS takes care of all the infrastructure needed to run and scale your application.

### Key Features of AWS Lambda:

1. **Serverless**:
   - You don’t have to worry about provisioning or managing servers. AWS Lambda automatically manages the compute resources for you, scaling them as needed based on incoming requests or events.
   - This eliminates the need to maintain infrastructure and reduces overhead.

2. **Event-Driven**:
   - AWS Lambda is designed to be triggered by various AWS services or external events, such as:
     - **S3** events (e.g., file uploads)
     - **API Gateway** requests (for building APIs)
     - **DynamoDB** streams (e.g., when data is added/modified)
     - **CloudWatch Events** (e.g., scheduled jobs)
     - **SNS** (Simple Notification Service) messages
     - **Cognito** triggers (for user sign-up/sign-in events)
     - And many other sources (including custom event sources).

3. **Scalability**:
   - AWS Lambda automatically scales the number of execution environments to match the incoming event load. If there are hundreds or thousands of events, Lambda can scale to handle them without any manual intervention.
   - It scales **horizontally** by running multiple instances of your function in parallel when needed.

4. **Pay-As-You-Go Pricing**:
   - With AWS Lambda, you only pay for the compute time you use, i.e., the time your code runs. You are billed based on the number of requests and the duration of your code execution (in milliseconds).
   - No charges for idle time – Lambda only charges when the function is triggered.


6. **Stateless**:
   - Each invocation of an AWS Lambda function is stateless, meaning it doesn’t retain any state between executions. If you need to maintain state, you can use AWS services like **DynamoDB** or **S3** to store persistent data.

7. **Customizable Execution Role**:
   - You can configure **IAM (Identity and Access Management)** roles for Lambda functions, granting them permissions to interact with other AWS services securely.
   - This enables Lambda functions to read from/write to S3, DynamoDB, or any other AWS service you need to interact with.

8. **Short-lived Execution**:
   - AWS Lambda functions can run for a maximum of 15 minutes per invocation. If the function doesn't complete within this time frame, it will be terminated. This makes Lambda best suited for tasks that can be completed quickly, such as real-time data processing, image resizing, API responses, etc.

9. **Logging and Monitoring**:
   - AWS Lambda integrates with **Amazon CloudWatch** for logging and monitoring, so you can track metrics such as the number of invocations, execution time, error rates, and more.
   - Logs are automatically generated by Lambda, making it easy to debug and monitor function performance.

    
### Benefits of AWS Lambda:

- **No Server Management**: You don’t have to provision or manage servers.
- **Automatic Scaling**: Automatically scales depending on the number of requests/events, handling any workload.
- **Cost-Effective**: Pay only for the compute time used, with no cost for idle time.
- **Quick Deployment**: You can deploy your code in minutes, and AWS automatically handles the scaling and infrastructure.
- **Integrated with AWS Ecosystem**: Lambda integrates seamlessly with other AWS services like S3, DynamoDB, SNS, and more.



### AWS API Gateway

AWS API Gateway is a fully managed service provided by Amazon Web Services (AWS) that enables developers to create, publish, maintain, monitor, and secure APIs at any scale. API Gateway acts as an entry point for applications, enabling communication between client apps (mobile, web, etc.) and backend services (AWS Lambda, EC2, other HTTP services).

### Key Features of AWS API Gateway:
1. **Create and Manage APIs**: 
   - You can create RESTful APIs, WebSocket APIs, or HTTP APIs to connect to services like AWS Lambda, HTTP endpoints, or other AWS services.
   
2. **Support for Multiple Protocols**: 
   - API Gateway supports HTTP, WebSocket, and REST APIs, making it versatile for various use cases.
   
3. **Security**:
   - API Gateway allows you to authenticate and authorize API calls through services like AWS IAM (Identity and Access Management), Amazon Cognito, and Lambda authorizers.
   - It also supports encryption and custom domain names.

4. **Rate Limiting and Throttling**:
   - You can set rate limits and throttling policies to control traffic, protect backend resources, and prevent abuse.

5. **Scaling**:
   - API Gateway automatically scales to handle varying amounts of traffic, ensuring that your APIs perform well under different load conditions.

6. **Logging and Monitoring**:
   - It integrates with AWS CloudWatch for logging and monitoring API usage, errors, and performance metrics.
   
7. **Caching**:
   - API Gateway supports caching responses to reduce load on backend services, improving performance for repeated requests.

8. **Deployments and Versioning**:
   - You can manage different stages of an API (development, staging, production) and deploy changes in a controlled manner.

### Use Cases:
- **Serverless Applications**: Often used with AWS Lambda to create serverless APIs, where no infrastructure management is needed.
- **Microservices**: API Gateway can serve as the entry point to microservices, handling incoming requests and routing them to different backend services.
- **Mobile and Web Applications**: Provides a reliable way to manage API calls from mobile apps and websites.


### Benefits:
- **Low Management Overhead**: Fully managed service, so you don’t need to worry about server management or scaling.
- **Security**: Built-in support for securing APIs through authentication, authorization, and encryption.
- **Cost-Effective**: Pay only for the API calls you make, with no upfront costs or fixed fees.







## WebSockets

**WebSockets** are a communication protocol that enables **full-duplex** (two-way) communication channels over a single, long-lived connection between a client (usually a web browser) and a server. Unlike the traditional HTTP request-response model, which is **stateless** and works in a **request-response** pattern, WebSockets provide a persistent, open connection that allows continuous, real-time data exchange between the client and server.

### Key Features of WebSockets:

1. **Full-Duplex Communication**:
   - WebSockets allow both the client and the server to send messages to each other independently, at any time, over a single connection. This allows for real-time interactions, making it ideal for applications like live chats, online gaming, financial apps, etc.

2. **Persistent Connection**:
   - Once established, a WebSocket connection remains open until either the client or the server decides to close it. This eliminates the need to repeatedly open and close connections, reducing the overhead compared to traditional HTTP requests.

3. **Low Latency**:
   - WebSockets provide a low-latency communication channel because there’s no need to establish a new connection for each message. Once the connection is established, messages can be sent and received instantly.

4. **Efficient Communication**:
   - WebSockets reduce the amount of data overhead, as there’s no need for the repeated HTTP headers that occur with each request in a standard HTTP communication. This makes WebSockets more efficient for applications requiring frequent communication.

5. **Bidirectional**:
   - Unlike HTTP, which only allows the client to request and the server to respond, WebSockets enable both the client and the server to send messages at any time. This allows for real-time updates (e.g., chat messages, notifications, live score updates).

### How WebSockets Work:

1. **Handshake**:
   - A WebSocket connection starts with an HTTP handshake. The client sends an HTTP request to the server with an **Upgrade** header, indicating that it wants to establish a WebSocket connection.
   
   - Example WebSocket request:
     ```
     GET /chat HTTP/1.1
     Host: example.com
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
     Sec-WebSocket-Version: 13
     ```

2. **Connection Upgrade**:
   - If the server supports WebSockets, it responds with a status code **101 Switching Protocols**, indicating that the protocol has been switched to WebSocket and the connection is now open.
   
   - Example WebSocket response:
     ```
     HTTP/1.1 101 Switching Protocols
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Accept: dGhlIHNhbXBsZSBub25jZQ==
     ```

3. **Data Exchange**:
   - After the handshake, the connection is upgraded to WebSocket, and both the client and the server can send messages back and forth in real time.
   - WebSocket messages can be sent in text or binary format, making it flexible for various types of data.

4. **Closing the Connection**:
   - Either the client or the server can close the WebSocket connection at any time by sending a **close frame**. Once the connection is closed, no more messages can be sent or received.

### Common Use Cases of WebSockets:

1. **Real-Time Messaging and Chat Applications**:
   - WebSockets are ideal for applications like live chat or messaging, where users need instant communication with each other.
   
2. **Online Gaming**:
   - In multiplayer games, WebSockets enable fast, real-time communication between players, which is crucial for game states, actions, and updates.
   
3. **Stock Market or Financial Applications**:
   - Financial apps that require real-time updates (e.g., stock prices, cryptocurrency rates) benefit from WebSockets because of the low latency and continuous data flow.
   
4. **Live Sports Updates**:
   - WebSockets allow sports applications to push live scores, statistics, and news to users without requiring them to refresh the page.

5. **Collaborative Applications**:
   - Applications like collaborative document editing (e.g., Google Docs) require real-time updates to synchronize changes made by different users.

6. **IoT (Internet of Things)**:
   - WebSockets are also useful for real-time communication between IoT devices (e.g., smart home devices, sensors) and control systems, where the devices need to send continuous streams of data.

7. **Push Notifications**:
   - WebSockets can be used for implementing push notifications in web applications, allowing users to receive instant alerts about various events (e.g., new messages, system updates).

### Example WebSocket Usage:

Here’s a basic example of how WebSocket communication works in a **web browser** using JavaScript (client-side) and **Node.js** (server-side).

#### **Client-Side (JavaScript - Browser)**:

```javascript
// Create a new WebSocket connection to the server
const socket = new WebSocket('ws://localhost:8080');

// When the WebSocket connection is established
socket.onopen = function(event) {
    console.log("Connected to the server!");
    socket.send('Hello, Server!');
};

// When a message is received from the server
socket.onmessage = function(event) {
    console.log("Message from server:", event.data);
};

// When the WebSocket connection is closed
socket.onclose = function(event) {
    console.log("Disconnected from the server.");
};

// Handling errors
socket.onerror = function(error) {
    console.log("WebSocket error:", error);
};
```

#### **Server-Side **:


To create a WebSocket server in Python, you can use the `websockets` library, which provides an easy way to handle WebSocket connections. 
First, you'll need to install the `websockets` library. You can do that by running:

```bash
pip install websockets
```

##### Server-Side WebSocket Example in Python:

Here is a simple WebSocket server in Python using the `websockets` library:

```python
import asyncio
import websockets

# This function will handle a WebSocket connection from the client
async def echo(websocket, path):
    # Print when a new client connects
    print(f"Client connected: {path}")
    
    # Send a welcome message to the client
    await websocket.send("Hello, Client!")

    try:
        # Wait for messages from the client
        async for message in websocket:
            print(f"Received from client: {message}")
            # Echo the received message back to the client
            await websocket.send(f"Echo: {message}")
    except websockets.exceptions.ConnectionClosed as e:
        print(f"Connection closed: {e}")
    finally:
        print("Connection closed by client.")

# Start the WebSocket server
async def main():
    # Start the WebSocket server on localhost:8765
    async with websockets.serve(echo, "localhost", 8765):
        print("Server started on ws://localhost:8765")
        # Run the server indefinitely
        await asyncio.Future()  # This will keep the server running

# Run the main coroutine
if __name__ == "__main__":
    asyncio.run(main())
```

##### Explanation of the Code:

1. **`echo` Function**:
   - This function handles the WebSocket connection for each client. It first sends a welcome message to the client and then listens for messages from the client. Any message received from the client is echoed back with the prefix "Echo: ".
   
2. **`main` Function**:
   - This function starts the WebSocket server by calling `websockets.serve(echo, "localhost", 8765)`, which listens for incoming WebSocket connections on `ws://localhost:8765`.
   - The `asyncio.Future()` keeps the server running indefinitely by waiting for events (like new incoming connections).

3. **Running the Server**:
   - The server will print `"Server started on ws://localhost:8765"` when it is up and running, and it will listen for incoming WebSocket connections.
   - If a client sends a message, the server will log the message and send it back (echo).

##### 3. Client-Side Example in JavaScript (Web Browser):

You can test this WebSocket server using the following JavaScript client code in the browser:

```javascript
// Create a new WebSocket connection to the server
const socket = new WebSocket('ws://localhost:8765');

// When the WebSocket connection is established
socket.onopen = function(event) {
    console.log("Connected to the server!");
    socket.send('Hello, Server!');
};

// When a message is received from the server
socket.onmessage = function(event) {
    console.log("Message from server:", event.data);
};

// When the WebSocket connection is closed
socket.onclose = function(event) {
    console.log("Disconnected from the server.");
};

// Handling errors
socket.onerror = function(error) {
    console.log("WebSocket error:", error);
};
```

##### How to Test:

1. **Run the Python WebSocket Server**:
   - Save the Python WebSocket server code to a file (e.g., `websocket_server.py`).
   - Run the server:
     ```bash
     python websocket_server.py
     ```

2. **Run the JavaScript Client**:
   - You can open the JavaScript code in the browser by saving it in an HTML file or running it in the browser console.
   
   Example HTML file:
   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>WebSocket Client</title>
   </head>
   <body>
       <h1>WebSocket Client</h1>
       <script src="client.js"></script>
   </body>
   </html>
   ```

   Save the JavaScript code in a file called `client.js`, then open the HTML file in your web browser.

##### 4. WebSocket Client (Python Example):

You can also write a Python WebSocket client to test the server using the `websockets` library:

```python
import asyncio
import websockets

async def hello():
    uri = "ws://localhost:8765"
    async with websockets.connect(uri) as websocket:
        # Send a message to the server
        await websocket.send("Hello, Server!")
        
        # Receive the response from the server
        response = await websocket.recv()
        print(f"Response from server: {response}")

# Run the client
asyncio.run(hello())
```















### Advantages of WebSockets:

- **Real-Time Communication**: WebSockets enable instant communication between the client and server, making them ideal for real-time applications.
- **Reduced Latency**: Since the connection is persistent, there’s no need to repeatedly open and close connections, which results in lower latency.
- **Efficiency**: WebSockets use less bandwidth and are more efficient than HTTP for frequent message exchanges, as they avoid the overhead of HTTP headers with every request.
- **Lower Overhead**: There’s less overhead compared to HTTP polling or long-polling because WebSockets maintain a single connection, and data can be sent immediately when available.

### Limitations of WebSockets:

- **Browser and Network Compatibility**: WebSockets require support from the client (browser or app) and the server. Some firewalls or proxies might block WebSocket traffic.
- **Single Connection**: WebSockets typically use a single connection for each client, which can become limiting if you need to scale to millions of users.
- **No Built-In Message Queuing**: WebSockets don’t provide built-in message persistence, so you need to implement your own system for queuing or persisting messages.







# Tasks

## Task 8.1: Simple serverless web application

### CRUD REST API : The 4 Basic Operations in Software Development

**CRUD** stands for **Create, Read, Update, Delete**, which are the four fundamental operations used in databases and APIs to manage data.

| **Operation** | **Description** | **Example in SQL** | **Example in REST API** |
|--------------|---------------|-------------------|------------------|
| **Create**   | Adds new data | `INSERT INTO users (name, email) VALUES ('John', 'john@example.com');` | `POST /users` |
| **Read**     | Retrieves data | `SELECT * FROM users WHERE id = 1;` | `GET /users/1` |
| **Update**   | Modifies existing data | `UPDATE users SET name = 'Jane' WHERE id = 1;` | `PUT /users/1` |
| **Delete**   | Removes data | `DELETE FROM users WHERE id = 1;` | `DELETE /users/1` |

Such operations can be applied in different contexts.

- **REST APIs**: CRUD maps to HTTP methods (`POST`, `GET`, `PUT`, `DELETE`).
- **Databases**: CRUD operations are used to manipulate records (SQL, MongoDB, Firebase).
- **User Interfaces**: A CRUD-based UI allows users to **add, view, edit, and delete** items.

In this lab session we'll be creating a REST API. Therefore, you first, create a DynamoDB table named `ccbda-lambda-first` with `thingID` as the partition key. Then, download the repository from [this link](https://github.com/CCBDA-UPC/serverless-app) as a ZIP file and add it to your project repository.

### Deploying the CRUD Lambda function

Inside the `crud` folder, you'll find an AWS Lambda function written in Python. This function establishes a connection to DynamoDB and waits to be invoked by AWS API Gateway. Depending on the HTTP method (GET, POST, etc.) received, it will perform different operations on the database.

We’ll use `kwargs` to dynamically pass the values of parameters directly to the `boto3` operations in our Lambda function.

```python
import boto3
import json
import logging

logger = logging.getLogger()
logger.setLevel(logging.INFO)

dynamodb = boto3.client('dynamodb', region_name='us-east-1')

def lambda_handler(event, context):
    operation = event['requestContext']['http']['method']
    logger.info(f'operation {operation}')
    try:
        if operation == 'GET':
            return respond(dynamodb.scan(**event['queryStringParameters']))
        elif operation == 'POST':
            return respond(dynamodb.put_item(**json.loads(event['body'])))
        elif operation == 'DELETE':
            return respond(dynamodb.delete_item(**json.loads(event['body'])))
        elif operation == 'PUT':
            return respond(dynamodb.update_item(**json.loads(event['body'])))
        elif operation == 'OPTIONS':
            return respond('')
        else:
            return respond(None, f'Unsupported method "{operation}"')
    except Exception as e:
        respond(None, f'{type(e).__name__} at line {e.__traceback__.tb_lineno} of {__file__}: {e}')

def respond(res, err=None):
    response = {
        'statusCode': '200' if err is None else '400',
        'body': json.dumps(res) if err is None else err,
        'headers': {
            'Content-Type': 'application/json',
            "Access-Control-Allow-Headers": "Content-Type",
            'Access-Control-Allow-Origin': '*',
            "Access-Control-Allow-Methods": "GET, POST, DELETE, PUT, OPTIONS",
        },
    }
    logger.info(f'response {json.dumps(response, indent=2)}')
    return response
```

The file `requirements.txt` defines the Python environment for the above function to be executed.

We are going to use the AWS CLI to deploy the Lambda function and build the **API Gateway**. Open a terminal and set the variables to the corresponding value. The command `aws lambda create-function` sends the zip file with the Python code and requirements to AWS. In response it obtains a JSON record with some values that we'll be needing to use for future steps, i.e. `LAMBDA_ARN` needs to be updated to the value of the response field `FunctionArn`.

```bash
_$ ACCOUNT_ID=<YOUR-ACCOUNT-ID>
_$ REGION=us-east-1
_$ cd crud
_$ zip lambda_crud.zip lambda_crud.py requirements.txt
updating: lambda_crud.py (deflated 64%)
updating: requirements.txt (deflated 19%)
_$ aws lambda create-function --function-name LambdaCRUD \
  --zip-file fileb://lambda_crud.zip \
  --handler lambda_crud.lambda_handler \
  --runtime python3.13 \
  --role arn:aws:iam::${ACCOUNT_ID}:role/LabRole
{
    "FunctionName": "LambdaCRUD",
    "FunctionArn": "arn:aws:lambda:us-east-1:<YOUR-ACCOUNT-ID>:function:LambdaCRUD",
    "Runtime": "python3.13",
    "Role": "arn:aws:iam::992382765078:role/LabRole",
    "Handler": "lambda_crud.lambda_handler",
    "CodeSize": 1147,
    "Description": "",
    "Timeout": 3,
    "MemorySize": 128,
    "LastModified": "2025-04-03T15:24:35.266+0000",
    "CodeSha256": "CX13dQVlx3hpf3YOcDh07USeHFRcGLfjX6hTKiF/bX8=",
    "Version": "$LATEST",
    "TracingConfig": {
        "Mode": "PassThrough"
    },
    "RevisionId": "ae25f8b8-1d06-4bc9-826e-3d56c0df3d0e",
    "State": "Pending",
    "StateReason": "The function is being created.",
    "StateReasonCode": "Creating"
}
_$ LAMBDA_ARN="arn:aws:lambda:us-east-1:<YOUR-ACCOUNT-ID>:function:LambdaCRUD"
```

In Unix, using the command `jq` ([more info](https://jqlang.org/)) and the backquotes ``` we can automatically set the value of the LAMBDA_ARN variable.

```bash
_$ LAMBDA_ARN=`aws lambda create-function --function-name LambdaCRUD \
  --zip-file fileb://lambda_crud.zip \
  --handler lambda_crud.lambda_handler \
  --runtime python3.13 \
  --role arn:aws:iam::${ACCOUNT_ID}:role/LabRole \
  | jq '.FunctionArn' `
_$ echo $LAMBDA_ARN
"arn:aws:lambda:us-east-1:<YOUR-ACCOUNT-ID>:function:LambdaCRUD"
```

Go to the AWS Lambda console and see the outcome of the above commands.

<img alt="Lab08-LambdaConsole.png" src="images/Lab08-LambdaConsole.png" width="100%"/>


### API Gateway creation

It is now necessary to create a unique value for the parameter `statement-id`. The Unix command `uuidgen` creates a random value. The command `aws lambda add-permission` allows the Lambda function to be accessed by any API Gateway.

```bash
_$ STATEMENT_ID=`uuidgen`
_$ echo $STATEMENT_ID
CDCFB599-79CC-4877-B480-6B97B4125D4D
_$ aws lambda add-permission \
  --function-name LambdaCRUD \
  --principal apigateway.amazonaws.com \
  --statement-id "${STATEMENT_ID}" \
  --action lambda:InvokeFunction
{
    "Statement": "{\"Sid\":\"CDCFB599-79CC-4877-B480-6B97B4125D4D\",\"Effect\":\"Allow\",\"Principal\":{\"Service\":\"apigateway.amazonaws.com\"},\"Action\":\"lambda:InvokeFunction\",\"Resource\":\"arn:aws:lambda:us-east-1:992382765078:function:LambdaCRUD\"}"
}
```

Once the Lambda function is deployed we'll go and create the API Gateway name ("CrudHttpAPI") and type (HTTP). Use the "ApiId" field to set the value of the variable `API_ID` or use `jq` instead.

```bash
_$ aws apigatewayv2 create-api \
  --name "CrudHttpAPI" \
  --protocol-type HTTP
{
    "ApiEndpoint": "https://9h1wag0ywe.execute-api.us-east-1.amazonaws.com",
    "ApiId": "9h1wag0ywe",
    "ApiKeySelectionExpression": "$request.header.x-api-key",
    "CreatedDate": "2025-04-03T15:25:33+00:00",
    "Name": "CrudHttpAPI",
    "ProtocolType": "HTTP",
    "RouteSelectionExpression": "$request.method $request.path"
}
_$ API_ID=9h1wag0ywe
```

The following step binds the created API Gateway with the Lambda function deployed before. Make sure that you save the value of the `INTEGRATION_ID` variable using the "IntegrationId" response field.

```bash
_$ aws apigatewayv2 create-integration \
    --api-id ${API_ID} \
    --integration-type AWS_PROXY \
    --integration-uri ${LAMBDA_ARN} \
    --integration-method ANY \
    --payload-format-version 2.0
{
    "ConnectionType": "INTERNET",
    "IntegrationId": "wp0uj9i",
    "IntegrationMethod": "ANY",
    "IntegrationType": "AWS_PROXY",
    "IntegrationUri": "arn:aws:lambda:us-east-1:992382765078:function:LambdaCRUD",
    "PayloadFormatVersion": "2.0",
    "TimeoutInMillis": 30000
}
_$ INTEGRATION_ID=wp0uj9i
```

The next step is to create different routes in the API Gateway for each HTTP method. In this example all methods use the same Lambda function, but usually different Lambda functions serve each HTTP method.

```bash
_$ aws apigatewayv2 create-route \
  --api-id ${API_ID} \
  --route-key "GET /" \
  --target "integrations/${INTEGRATION_ID}"
{
    "ApiKeyRequired": false,
    "AuthorizationType": "NONE",
    "RouteId": "6jrmmkf",
    "RouteKey": "GET /",
    "Target": "integrations/wp0uj9i"
}
_$ aws apigatewayv2 create-route \
  --api-id ${API_ID} \
  --route-key "POST /" \
  --target "integrations/${INTEGRATION_ID}"
{
    "ApiKeyRequired": false,
    "AuthorizationType": "NONE",
    "RouteId": "zay7v4g",
    "RouteKey": "POST /",
    "Target": "integrations/wp0uj9i"
}
_$ aws apigatewayv2 create-route \
  --api-id ${API_ID} \
  --route-key "OPTIONS /" \
  --target "integrations/${INTEGRATION_ID}"
{
    "ApiKeyRequired": false,
    "AuthorizationType": "NONE",
    "RouteId": "b2qe62a",
    "RouteKey": "OPTIONS /",
    "Target": "integrations/wp0uj9i"
}
_$ aws apigatewayv2 create-route \
  --api-id ${API_ID} \
  --route-key "PUT /" \
  --target "integrations/${INTEGRATION_ID}"
{
    "ApiKeyRequired": false,
    "AuthorizationType": "NONE",
    "RouteId": "hjwebad",
    "RouteKey": "PUT /",
    "Target": "integrations/wp0uj9i"
}
_$ aws apigatewayv2 create-route \
  --api-id ${API_ID} \
  --route-key "DELETE /" \
  --target "integrations/${INTEGRATION_ID}"
{
    "ApiKeyRequired": false,
    "AuthorizationType": "NONE",
    "RouteId": "9kyl2hi",
    "RouteKey": "DELETE /",
    "Target": "integrations/wp0uj9i"
}
```

The API Gateway can have different stages: production, development, testing, etc. We are only going to create one stage named "prod" that will need to be manually deployed. Changing `--not-auto-deploy` to `--auto-deploy` will make it redeploy as soon as there is a change in the configuration or the Lambda function.

```bash
_$ STAGE="prod"
_$ aws apigatewayv2 create-stage \
  --api-id ${API_ID} \
  --stage-name ${STAGE}
  --no-auto-deploy
{
    "CreatedDate": "2025-04-03T15:30:24+00:00",
    "DefaultRouteSettings": {
        "DetailedMetricsEnabled": false
    },
    "LastUpdatedDate": "2025-04-03T15:30:25+00:00",
    "RouteSettings": {},
    "StageName": "prod",
    "StageVariables": {},
    "Tags": {}
}
```

Finally, the API Gateway is deployed and can be used. The URL is made of

https://${API_ID}.execute-api.${REGION}.amazonaws.com/${STAGE}/

```bash
_$ aws apigatewayv2 create-deployment --api-id ${API_ID} --stage-name prod
{
    "AutoDeployed": false,
    "CreatedDate": "2025-04-03T15:40:58+00:00",
    "DeploymentId": "01jigd",
    "DeploymentStatus": "DEPLOYED"
}
_$ URL="https://${API_ID}.execute-api.${REGION}.amazonaws.com/${STAGE}/"
_$ echo $URL
https://9h1wag0ywe.execute-api.us-east-1.amazonaws.com/prod/
```

Go to the AWS API Gateway console and see the outcome of the above commands.

<img alt="Lab08-APIGateway.png" src="images/Lab08-APIGateway.png" width="100%"/>

### Test the API

[**Postman**](https://www.postman.com) is a popular API development and testing tool that allows developers to send HTTP requests to web servers and view responses. It provides an easy-to-use interface for testing RESTful APIs, making it simple to construct and send requests, view responses, and automate tests. Postman supports features like request chaining, environment variables, collections, and collaboration, making it a powerful tool for API development and debugging.

Use this [URL](https://www.postman.com/ccbda-upc-edu/serverless/request/ck4fxrd/testing?action=share&creator=43659146&ctx=documentation&active-environment=43659146-8433b233-679d-4f13-a332-b972334ca409) to access the Postman web interface. You can also download the desktop app and import the Testing operations into your laptop. 

The Testing collection is using two variables defined in the CRUD environment. Make sure that the CRUD environment is selected before testing the HTTP operations.

<img alt="Lab08-Postman-collections.png" src="images/Lab08-Postman-collections.png" width="100%"/>

<img alt="Lab08-Postman-environments.png" src="images/Lab08-Postman-environments.png" width="100%"/>


Once the API is deployed, you can test it using the files in the `webpage1` folder. But before, you need to change the value of the variable `apiUrl` to the value obtained above.

The JavaScript code uses jQuery to create a "GET" request as soon as the web page loads and a "POST" request when the visitor submits the form.

```javascript
(function ($) {
    apiUrl = "https://9h1wag0ywe.execute-api.us-east-1.amazonaws.com/prod/"
    TableName = 'ccbda-lambda-first';

    $.ajax({
        type: 'GET',
        url: apiUrl,
        data: {'TableName': TableName},
        crossDomain: true,
        success: function (result) {
            $.each(result.Items, function (i, item) {
                $('#items').append('<li>' + item.thingID.S + '</li>');
            });
        },
        error: function (xhr, status, error) {
            $('#error').toggle().append('<div>' + error + '</div>');
        }
    });

    // Form submit
    $("#form").submit(function (event) {
        event.preventDefault();
        thingID = $('#thingID').val();
        payload = {
            'TableName': TableName,
            'Item': {
                'thingID': {
                    'S': thingID
                }
            }
        }
        $.ajax({
            type: 'POST',
            url: apiUrl,
            crossDomain: true,
            contentType: 'application/json',
            data: JSON.stringify(payload),
            cache: false,
            success: function (result) {
                $('#thingID').val('');
                $('#items').append('<li>' + thingID + '</li>');
            },
            error: function (xhr, status, error) {
                $('#error').toggle().append('<div>' + status + ',' + error + '</div>');
            }
        });
    });
})(jQuery);
```

Open the "index.html" file using your browser and start to create items in the list.

<img alt="Lab08-webpage.png" src="images/Lab08-webpage.png" width="80%"/>


### **Step 4: Deploy and Monitor**

Once your API is deployed and working, you can monitor its usage in the AWS API Gateway and Lambda dashboards:
- **API Gateway**: You can track metrics like the number of requests, latency, and any errors.
- **Lambda**: Use AWS CloudWatch Logs to view detailed logs for each invocation of your Lambda function.

### **Explanation of the Components**:
1. **Lambda Function**: This is where you process the incoming API requests. In the example, we simply return a JSON message with a "Hello from Lambda!" message.
2. **API Gateway**: Acts as the entry point to your API, routing incoming HTTP requests to the appropriate Lambda function.
3. **Requests Library in Python**: The `requests` library is used to send HTTP requests from your local machine or another system to the API Gateway endpoint.

### **Additional Features**:
- You can handle more HTTP methods like `POST`, `PUT`, or `DELETE` by adding additional logic in your Lambda function.
- Use **API Gateway Authorizers** (like IAM roles, Lambda authorizers, or Cognito) to secure your API.
- You can also enable **CORS** (Cross-Origin Resource Sharing) in API Gateway if you need to access the API from a frontend application hosted on a different domain.

This is a basic example to get you started. You can expand it by adding more resources, using environment variables, setting up custom domains, and more depending on your needs.



## AWS CLI for API Gateway

Creating a **WebSocket API** with the **AWS CLI** involves a few steps, and it requires using the **API Gateway WebSocket** feature, which allows you to build real-time, bidirectional communication between clients and servers.

Here's how you can create a WebSocket API using the AWS CLI.

### Steps to Create a WebSocket API Using AWS CLI:

#### 1. **Create the WebSocket API**

To create a WebSocket API, use the `create-rest-api` command but specify that you want to create a WebSocket API instead of a regular REST API.

```bash
aws apigatewayv2 create-api \
  --name "MyWebSocketAPI" \
  --protocol-type WEBSOCKET \
  --route-selection-expression "$request.body.action"
```

- `--name`: Name of the WebSocket API.
- `--protocol-type`: This should be set to `WEBSOCKET` for WebSocket APIs.
- `--route-selection-expression`: This defines the routing logic based on the WebSocket messages. In this example, it routes based on the `action` field in the incoming WebSocket messages (`$request.body.action`).

The output of this command will return a JSON object with the API's information, including the `ApiId`. You’ll need this `ApiId` for subsequent steps.

Example output:
```json
{
    "ApiEndpoint": "wss://m96mpy7qz4.execute-api.us-east-1.amazonaws.com",
    "ApiId": "m96mpy7qz4",
    "ApiKeySelectionExpression": "$request.header.x-api-key",
    "CreatedDate": "2025-04-02T14:43:51+00:00",
    "Name": "MyWebSocketAPI",
    "ProtocolType": "WEBSOCKET",
    "RouteSelectionExpression": ".body.action"
}
```

#### 2. **Create WebSocket Routes**

In a WebSocket API, you define **routes** that map to different actions or message types. For example, you may define routes for `connect`, `disconnect`, and custom message types like `sendMessage`.

- **Connect Route**: Triggered when a client connects to the WebSocket.
- **Disconnect Route**: Triggered when a client disconnects.
- **Custom Routes**: Any custom action you want to handle in your WebSocket API.

Let’s create the `connect` and `disconnect` routes:

```bash
aws apigatewayv2 create-route \
  --api-id m96mpy7qz4 \
  --route-key "$connect" \
  --target "integrations/<integration-id>"
```

```bash
aws apigatewayv2 create-route \
  --api-id m96mpy7qz4 \
  --route-key "$disconnect" \
  --target "integrations/<integration-id>"
```

- Replace `m96mpy7qz4` with your actual `ApiId` from the previous step.
- `--route-key`: This is the route identifier. For the `connect` route, use `$connect`, and for the `disconnect` route, use `$disconnect`.

#### 3. **Create WebSocket Integration**

Next, we need to integrate the routes with a backend service, which is usually an **AWS Lambda function**. You can create an integration with a Lambda function or other AWS services like **DynamoDB** or **SNS**.

Here’s an example of how to create an integration with a Lambda function:

```bash
aws apigatewayv2 create-integration \
  --api-id m96mpy7qz4 \
  --integration-type AWS_PROXY \
  --integration-uri arn:aws:lambda:us-west-2:123456789012:function:MyLambdaFunction \
  --payload-format-version 2.0
```

- `--integration-type`: Use `AWS_PROXY` if you want to proxy the request directly to Lambda.
- `--integration-uri`: The ARN of the Lambda function that will handle the WebSocket connection.
- `--payload-format-version`: Version of the WebSocket payload (use `2.0` for WebSocket APIs).

Once you create this integration, you can reference its ID (`<integration-id>`) in the `create-route` commands for the WebSocket routes.

#### 4. **Grant API Gateway Permission to Invoke Lambda**

Before API Gateway can invoke your Lambda function, you need to add permissions for it to do so. You can do that with the following command:

```bash
aws lambda add-permission --function-name MyLambdaFunction \
  --principal apigateway.amazonaws.com \
  --statement-id <unique-id> \
  --action "lambda:InvokeFunction"
```

- Replace `MyLambdaFunction` with your Lambda function name.
- Replace `<unique-id>` with a unique string (e.g., `websocket-api-invoke`).

#### 5. **Deploy the WebSocket API**

To make your WebSocket API live, you need to deploy it to a stage (e.g., `prod` or `dev`). You can do that using the following command:

```bash
aws apigatewayv2 create-stage \
  --api-id m96mpy7qz4 \
  --stage-name prod \
  --auto-deploy
```

- Replace `m96mpy7qz4` with your `ApiId`.
- `--stage-name`: The name of the deployment stage (e.g., `prod`).
- `--auto-deploy`: This automatically deploys the API to the stage.

#### 6. **Test the WebSocket API**

After deployment, your WebSocket API will be available at the following URL format:

```
wss://<api-id>.execute-api.<region>.amazonaws.com/prod
```

For example, if your API ID is `m96mpy7qz4`, your WebSocket URL will be:

```
wss://m96mpy7qz4.execute-api.us-west-2.amazonaws.com/prod
```

You can use WebSocket clients like **wscat** or WebSocket libraries in your preferred language to test the connection:

```bash
wscat -c wss://m96mpy7qz4.execute-api.us-west-2.amazonaws.com/prod
```

---

### Summary of AWS CLI Commands for WebSocket API:

1. **Create the WebSocket API**:
   ```bash
   aws apigatewayv2 create-api \
     --name "MyWebSocketAPI" \
     --protocol-type WEBSOCKET \
     --route-selection-expression "$request.body.action"
   ```

2. **Create Routes (e.g., connect, disconnect)**:
   ```bash
   aws apigatewayv2 create-route \
     --api-id m96mpy7qz4 \
     --route-key "$connect" \
     --target "integrations/<integration-id>"
   ```

   ```bash
   aws apigatewayv2 create-route \
     --api-id m96mpy7qz4 \
     --route-key "$disconnect" \
     --target "integrations/<integration-id>"
   ```

3. **Create Lambda Integration**:
   ```bash
   aws apigatewayv2 create-integration \
     --api-id m96mpy7qz4 \
     --integration-type AWS_PROXY \
     --integration-uri arn:aws:lambda:us-west-2:123456789012:function:MyLambdaFunction \
     --payload-format-version 2.0
   ```

4. **Grant API Gateway Permission to Invoke Lambda**:
   ```bash
   aws lambda add-permission --function-name MyLambdaFunction \
     --principal apigateway.amazonaws.com \
     --statement-id <unique-id> \
     --action "lambda:InvokeFunction"
   ```

5. **Deploy the WebSocket API**:
   ```bash
   aws apigatewayv2 create-stage \
     --api-id m96mpy7qz4 \
     --stage-name prod \
     --auto-deploy
   ```

6. **Test the WebSocket API**:
   - Use `wscat` or any WebSocket client to connect to:
     ```bash
     wscat -c wss://m96mpy7qz4.execute-api.us-west-2.amazonaws.com/prod
     ```















## AWS CLI for Lambda

Deploying a Lambda function using the AWS CLI involves a few steps. Here's a comprehensive guide to deploying your Lambda function from the command line.

### Prerequisites:

1. **AWS CLI Installed**: Ensure the AWS Command Line Interface (CLI) is installed on your machine. You can install it by following the instructions [here](https://aws.amazon.com/cli/).

2. **AWS Account and Credentials**: Ensure you have an AWS account, and your AWS credentials are configured (Access Key ID and Secret Access Key) using the `aws configure` command.
   ```bash
   aws configure
   ```
   - Enter your **AWS Access Key** and **Secret Access Key**.
   - Enter the **Region** where your Lambda function will be deployed (e.g., `us-west-2`).
   - Enter the **default output format** (e.g., `json`).

3. **IAM Role for Lambda**: Ensure you have an IAM role for your Lambda function that grants necessary permissions. Lambda requires a role with policies like `AWSLambdaBasicExecutionRole` to write logs to CloudWatch.

### Steps to Deploy a Lambda Function Using AWS CLI:

#### 1. **Write Your Lambda Function Code**

Create a file with your Lambda function code. For example, let's use a simple Python Lambda function (`lambda_function.py`).

```python
def lambda_handler(event, context):
    return {
        'statusCode': 200,
        'body': 'Hello from Lambda!'
    }
```

#### 2. **Create a ZIP Archive of Your Code**

You need to package your Lambda function into a ZIP file before deploying. If your Lambda code is in a single file (like `lambda_function.py`), you can run the following command to create the ZIP:

```bash
zip function.zip lambda_function.py
```

If you have additional dependencies, you need to install them first into a directory and include them in the ZIP file. Here’s how to package everything together:

```bash
mkdir my_lambda_package
cd my_lambda_package
# Copy your lambda function code into this directory
cp ../lambda_function.py .

# If you have any dependencies, install them into the directory
# Example (if you have external libraries):
# pip install requests -t .

# Zip everything
zip -r ../function.zip .
cd ..
```

#### 3. **Create an IAM Role for Lambda (If Not Already Created)**

If you don't have an IAM role with the necessary permissions for Lambda, you can create one using the following steps:

```bash
aws iam create-role --role-name lambda-execution-role \
  --assume-role-policy-document file://trust-policy.json
```

`trust-policy.json` is a JSON file defining the trust relationship between AWS Lambda and IAM, and it should look like this:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
```

You can also attach a basic Lambda execution policy (if not done yet) to the role for logging permissions:

```bash
aws iam attach-role-policy --role-name lambda-execution-role \
  --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
```

#### 4. **Deploy the Lambda Function Using the AWS CLI**

Now, you're ready to deploy the function. Use the following command to create the Lambda function:

```bash
aws lambda create-function --function-name my-lambda-function \
  --zip-file fileb://function.zip \
  --handler lambda_function.lambda_handler \
  --runtime python3.8 \
  --role arn:aws:iam::your-account-id:role/lambda-execution-role
```

- `--function-name`: The name you want to give to your Lambda function (e.g., `my-lambda-function`).
- `--zip-file`: The path to the ZIP file containing your Lambda function code (e.g., `fileb://function.zip`).
- `--handler`: The function that AWS Lambda will call when your function is invoked. It’s the file name (without the `.py` extension) and the function name (e.g., `lambda_function.lambda_handler`).
- `--runtime`: The runtime environment for the Lambda function. Use the appropriate runtime (e.g., `python3.8`, `nodejs14.x`, etc.).
- `--role`: The ARN (Amazon Resource Name) of the IAM role your Lambda function will assume.

Make sure to replace `your-account-id` with your actual AWS account ID.

#### 5. **Verify the Lambda Deployment**

To verify that the function has been created successfully, you can use the following command:

```bash
aws lambda get-function --function-name my-lambda-function
```

This will return metadata about the function you just created, including its ARN and other configuration details.

#### 6. **Invoke Your Lambda Function**

To invoke the Lambda function from the CLI and test it, use the following command:

```bash
aws lambda invoke --function-name my-lambda-function output.txt
```

- `--function-name`: The name of your Lambda function (e.g., `my-lambda-function`).
- `output.txt`: The file where the output from the Lambda function will be written.

If everything works fine, you'll see the result in `output.txt`.

#### 7. **Update an Existing Lambda Function (Optional)**

If you want to update an existing Lambda function, you can use the `update-function-code` command:

```bash
aws lambda update-function-code --function-name my-lambda-function \
  --zip-file fileb://function.zip
```

This will update the Lambda function code with the new contents of `function.zip`.

#### 8. **Delete the Lambda Function (Optional)**

If you want to delete the Lambda function after testing, you can do so with the following command:

```bash
aws lambda delete-function --function-name my-lambda-function
```

This removes the Lambda function from AWS.

---

### Summary of Commands

1. **Zip the Lambda code**:
   ```bash
   zip function.zip lambda_function.py
   ```

2. **Create the Lambda function**:
   ```bash
   aws lambda create-function --function-name my-lambda-function \
     --zip-file fileb://function.zip \
     --handler lambda_function.lambda_handler \
     --runtime python3.8 \
     --role arn:aws:iam::your-account-id:role/lambda-execution-role
   ```

3. **Invoke the Lambda function**:
   ```bash
   aws lambda invoke --function-name my-lambda-function output.txt
   ```

4. **Update the Lambda function** (if needed):
   ```bash
   aws lambda update-function-code --function-name my-lambda-function \
     --zip-file fileb://function.zip
   ```

5. **Delete the Lambda function** (if needed):
   ```bash
   aws lambda delete-function --function-name my-lambda-function
   ```

